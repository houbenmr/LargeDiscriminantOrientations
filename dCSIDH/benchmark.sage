# p4096 from https://eprint.iacr.org/2023/793

all_odd_primes = Primes()[1:263]
all_odd_primes.remove(347)
all_odd_primes.append(1699)

ells = all_odd_primes[6:]
number_of_odd_primes = len(ells)
M = prod(ells)

f = 2^1728
p = f*prod(all_odd_primes)-1

Fp = GF(p)

E0 = EllipticCurve([Fp(1), 0])

import time
import sys
import os

sys.path.append(os.path.abspath('../external_modules/KummerIsogeny'))

from kummer_line import KummerLine
from kummer_isogeny import KummerLineIsogeny

K0 = KummerLine(E0)

def find_torsion_basis(K):
    
    P = K.zero()
    Q = K.zero()
    
    while True:
    
        not_found = True
        
        while not_found:
        
            not_found = False
        
            x = Fp.random_element()
            T = ((p+1) // M) * K(x)
            
            for ell in ells:
                cofactor = M // ell
                if cofactor * T == K.zero():
                    not_found = True
                    break
        
        if Fp((x^3 + K.a()*x^2 + x)).is_square():
            P = T
        else:
            Q = T
        
        if not P == K.zero() and not Q == K.zero():
            break

    return P, Q

def group_action(K, P, Q, vec):
    
    cofactor = M
    
    left_kernel = Q
    right_kernel = P
    
    for i in range(number_of_odd_primes):
        ell = ells[i]
        exponent = vec[i]
        cofactor = cofactor // ell
        if exponent == 0:
            
            # In this case, we have to walk in the left direction
            # The kernel of the isogeny is generated by kernel_point, which is of order ell:
            
            kernel_point = cofactor * left_kernel
            phi = KummerLineIsogeny(K, kernel_point, ell)
            K = phi.codomain()
            
            # We push through the points

            left_kernel = phi(left_kernel)
            right_kernel = ell * phi(right_kernel)
            
        if exponent == 1:
            
            # In this case, we have to walk in the right direction
            # The kernel of the isogeny is generated by kernel_point, which is of order ell:
            
            kernel_point = cofactor * right_kernel
            phi = KummerLineIsogeny(K, kernel_point, ell)
            K = phi.codomain()
            
            # We push through the points

            right_kernel = phi(right_kernel)
            left_kernel = ell * phi(left_kernel)
            
    return K

P0, Q0 = find_torsion_basis(K0)

timing_data = []

for i in range(10):
    
    secret_alice = [randint(0,1) for ell in ells]
    secret_bob = [randint(0,1) for ell in ells]
    
    start = time.time()
    KA = group_action(K0, P0, Q0, secret_alice)
    end = time.time()

    print('Alice public keygen took time', end - start)

    timing_data.append(end-start)
    
    with open('timing-data.out', 'a') as op:
        op.write(str(end-start) + '\n')

    PA, QA = find_torsion_basis(KA)

    start = time.time()
    KBA = group_action(KA, PA, QA, secret_bob)
    end = time.time()
    
    print('Bob shared secret took time', end - start)

    timing_data.append(end-start)

    with open('timing-data.out', 'a') as op:
        op.write(str(end-start) + '\n')

from numpy import median, std
    
with open('bench.out', 'w') as op:
    op.write('Timing results for a 4096-bit dCSIDH group action' + '\n')
    op.write('The median is ' + str(median(timings)) + '\n')
    op.write('The standard deviation is ' + str(std(timings)))
